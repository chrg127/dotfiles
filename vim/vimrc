" Load pathogen
execute pathogen#infect()



"colors
set background=dark
set termguicolors
colorscheme palenight
let g:airline_theme="palenight"

" for statusline colors

" settings
" Jump to the last position when reopening a file
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
filetype plugin indent on
syntax on           " Will make sure the syntax is always on
syntax enable       

set showcmd 		" Show (partial) command in status line.
set noshowmode      " Already have it in statusline
set ruler           " Show line and column number
set relativenumber  " left column displays relative numbers lines
set number          " now with current line number instead of 0
set laststatus=2    " Always display the status line

set autoread        " Read open files when changed in the background
set autowrite		" Automatically save before commands like :next and :make

set ignorecase		" Do case insensitive matching
set smartcase       " Unless we type a capital

"set listchars=""    " Empty listchars
"set listchars=tab:>. " A tab will be displayed as >...
" set listchars+=trail;.
set fillchars=vert:¦

set smartcase		" Do smart case matching
set incsearch		" Incremental search
set hlsearch        " Highlight searches

set tabstop=4       " Tab = 4 spaces
set shiftwidth=4
set expandtab       " Insert spaces instead of tabs

"set nobackup        " Don't create backups and swap files
"set noswapfile

set splitright      " Splits
"set splitbelow

set foldmethod=indent   " Folding
set foldnestmax=10
set nofoldenable
set foldlevel=2

set cursorline      " Adds different background color to line on which cursor is on
autocmd WinEnter * setlocal cursorline
autocmd WinLeave * setlocal nocursorline

set wildmenu        " Enhanced command completion
set hidden		    " Hide buffers when they are abandoned
set showmatch		" Show matching bracket
set mouse=a		    " Enable mouse usage (all modes)
set history=200     " Keep 200 lines of command history
set ttimeoutlen=5   " Time to wait for a key sequence to complete. Keep low.
set ffs=unix,dos
set encoding=UTF-8
set exrc
set secure
"set grepprg=grep\ --color=always\ -n\ $*\
"set makeprg=make\ EXTRA_CFLAGS=fdiagnostics-color=always

" Airline settings
" let g:airline_powerline_fonts = 1  "use powerline fonts
" let g:airline_skip_empty_sections = 0
" let g:airline#parts#ffenc#skip_expected_string='utf-8 - unix'
" let g:airline#extensions#tabline#enabled = 1
" let g:airline#extensions#tabline#buffer_nr_show = 1
" let g:airline#extensions#whitespace#enabled = 0

" NERDtree settings
" close NERDTree if it's the last window opened
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
let NERDTreeDirArrows=1

" filetypes
au BufNewFile,BufRead *.asm,*.inc set filetype=snes
autocmd BufNewFile,BufRead *.qbs setfiletype qbs
autocmd BufNewFile,BufRead *.pro,*.pri set filetype=qmake
autocmd BufNewFile,BufRead *.qml setfiletype qml
autocmd BufNewFile,BufRead *.qrc setfiletype xml
autocmd BufNewFile,BufRead *.ts setfiletype xml
autocmd BufNewFile,BufRead *.ui setfiletype xml

" Language specific settings
" C
let c_gnu = 1
let c_space_errors = 1
let c_curly_error = 1
let c_ansi_typedefs = 1
let c_ansi_constants = 1

let g:currentmode={
    \ 'n'       : 'Normale'        ,
    \ 'no'      : 'N·Attesa'       ,
    \ 'v'       : 'Visuale'        ,
    \ 'V'       : 'V·Riga'         ,
    \ '\<c-v>'  : 'V·Blocco'       ,
    \ 's'       : 'Selezione'      ,
    \ 'S'       : 'S·Riga'         ,
    \ '^S'      : 'S·Blocco'       ,
    \ 'i'       : 'Inserisci'      ,
    \ 'R'       : 'Sostituisci'    ,
    \ 'Rv'      : 'V·Sostituisci'   ,
    \ 'c'       : 'Comando'        ,
    \ 'cv'      : 'Vim Ex'         ,
    \ 'ce'      : 'Ex'             ,
    \ 'r'       : 'Prompt'         ,
    \ 'rm'      : 'Di piu'          ,
    \ 'r?'      : 'Conferma'       ,
    \ '!'       : 'Shell'          ,
    \ 't'       : 'Terminale'      ,
    \}

let g:mode_colors={
    \ 'n'       : 'PMenuSel'    ,
    \ 'no'      : 'PMenuSel'    ,
    \ 'v'       : 'DiffChange'  ,
    \ 'V'       : 'DiffChange'  ,
    \ '\<c-v>'  : 'DiffChange'  ,
    \ 's'       : 'DiffDelete'  ,
    \ 'S'       : 'DiffDelete'  ,
    \ '^S'      : 'DiffDelete'  ,
    \ 'i'       : 'DiffAdd'     ,
    \ 'R'       : 'DiffDelete'  ,
    \ 'Rv'      : 'DiffDelete'  ,
    \ 'c'       : 'PMenuSel'    ,
    \ 'cv'      : 'PMenuSel'    ,
    \ 'ce'      : 'PMenuSel'    ,
    \ 'r'       : 'PMenuSel'    ,
    \ 'rm'      : 'PMenuSel'    ,
    \ 'r?'      : 'PMenuSel'    ,
    \ '!'       : 'PMenuSel'    ,
    \ 't'       : 'PMenuSel'    ,
    \}

" custom statusline
function! Status(winnum)
    let stat=''
    let active = a:winnum == winnr()
    
    let bufnum = winbufnr(a:winnum)
    let type = getbufvar(bufnum, '&buftype')
    let ismodified = getbufvar(bufnum, '&modified')
    let ismodifiable = getbufvar(bufnum, '&modifiable')
    let filetype = getbufvar(bufnum, '&ft')
    let readonly = getbufvar(bufnum, '&readonly')

    " create custom statusline for quickfix buffer and help buffer
    if type ==# 'quickfix'
        " if getwininfo(win_getid())[0]['loclist'] == 1
        "     let stat.=' Lista Posizioni '
        " else
        "     let stat.=' Lista Quickfix '
        " endif
        let stat.= active ? '%#PMenuSel#' : '%4*'
        let stat.=' %q %#StatusLine#'
        let stat.= exists('w:quickfix_title') ? ' ' . w:quickfix_title : ''
        let stat.='%<%='
        let stat.= active ? '%#PMenuSel#' : '%4*'
        let stat.=' %l/%L '
        return stat
    elseif type ==# 'help'
        let stat.= active ? '%#PMenuSel#' : '%4*'
        let stat.= ' Aiuto %#StatusLine#'
        let stat.= active ? '%3*' : ''
        let stat.=' %f%#StatusLine#'
        let stat.='%<%='
        let stat.=filetype . ' '
        let stat.= active ? '%#PMenuSel#' : '%4*'
        let stat.=' %l, %v :: %L '
        return stat
    endif
    
    if active
        let stat.='%#' . g:mode_colors[mode()] . '#'
        let stat.='  %{toupper(g:currentmode[mode()])}  '
    else
        let stat.='%4*  Inattivo  '
    endif
    let stat.='%#StatusLine#'
    let stat.=' %n: '
    let stat.=active ? '%3*' : ''
    let stat.='%f%#StatusLine#'
    let stat.=ismodified ? '%2* [+] %#StatusLine#' : ''
    let stat.=readonly || !ismodifiable ? '%1*  %#StatusLine#'   : ''
    let stat.='%w'
    let stat.='%<%='
    if filetype ==# ''
        let stat.='normal text '
    else
        let stat.=filetype . ' '
    endif
    let stat.= WebDevIconsGetFileTypeSymbol(bufname(bufnum)) . '  '
    let stat.= active ? '%#PMenuSel#' : '%4*'
    let stat.=' %l, %v :: %L '
    return stat
endfunction

" after :make, have the quick fix list open
autocmd QuickFixCmdPost * copen | RefreshStatus

function! s:RefreshStatus()
    " for each window
    for nr in range(1, winnr('$'))
        " set statusline to whatever Status() returns
        call setwinvar(nr, '&statusline', '%!Status(' . nr . ')')
    endfor
endfunction

command! RefreshStatus :call <SID>RefreshStatus()

augroup status
    autocmd!
    autocmd VimEnter,VimLeave,WinEnter,WinLeave,BufWinEnter,BufWinLeave * :RefreshStatus
augroup END

" mappings
" Set <Leader>
let mapleader = ","

" Disable arrow movement, resize splits instead.
nnoremap <Down>  :resize +2<CR>
nnoremap <Up>    :resize -2<CR>
nnoremap <Left>  :vertical resize +2<CR>
nnoremap <Right> :vertical resize -2<CR>

" Moves a line up/down
no <S-Down> ddp
no <S-Up> ddkP

" NERDtree shortcut
nnoremap <C-n> :NERDTreeToggle<CR>

" tagbar shortcut
nnoremap <F8> :TagbarToggle<CR>

" autoclosing brackets
inoremap (<CR> (<CR>)<Esc>O
inoremap {<CR> {<CR>}<Esc>O
inoremap {; {<CR>};<Esc>O
inoremap {, {<CR>},<Esc>O
inoremap [<CR> [<CR>]<Esc>O
inoremap [; [<CR>];<Esc>O
inoremap [, [<CR>],<Esc>O

" copy to system clipboard using ,c
xnoremap <leader>c "+y

" switch buffers using ,b
nnoremap <leader>b :b <C-d>
