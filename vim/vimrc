" load pathogen
execute pathogen#infect()

" ===== settings =====
syntax on
filetype plugin indent on

set nocompatible
set showcmd 		" Show (partial) command in status line.
set noshowmode      " Already have it in statusline
set ruler           " Show line and column number
set relativenumber  " left column displays relative numbers lines
set number          " now with current line number instead of 0
set laststatus=2    " Always display the status line
set autoread        " Read open files when changed in the background
set autowrite		" Automatically save before commands like :next and :make
set hlsearch        " Highlight searches
set ignorecase		" Do case insensitive matching
set incsearch		" Incremental search
set smartcase		" Do smart case matching
set tabstop=4       " Tab = 4 spaces
set expandtab       " Insert spaces instead of tabs
set shiftwidth=4    " Indent with 4 spaces
set splitright      " Splits
set foldmethod=indent   " Folding
set foldnestmax=10  " max nesting of folds
set nofoldenable    " open all folds automatically
set foldlevel=2
if (&diff ==# 0)    " cursorline with diff is shit
    set cursorline
    autocmd WinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
endif
set wildmenu        " Enhanced command completion
set hidden		    " Hide buffers when they are abandoned
set showmatch		" Show matching bracket
set mouse=a		    " Enable mouse usage (all modes)
set history=200     " Keep 200 lines of command history
set ttimeoutlen=5   " Time to wait for a key sequence to complete. Keep low.
set ffs=unix,dos
set encoding=UTF-8
set exrc            " read current dir's .vimrc
set secure          " secure local .vimrc by disabling some commands
set directory=~/.cache/vim/swap//   " set a cache directory for swap files
set linebreak
set clipboard+=unnamedplus
set suffixes=".bak,~,.o,.swp,.obj,.d"
set wildignore=*.o,*.d

" ===== colors =====
" colorscheme palenight
colorscheme dosboxblack
" let g:gruvbox_contrast_dark = 'hard'
" let g:gruvbox_italic = 1
" let g:gruvbox_underline = 1
" colorscheme gruvbox

" ===== misc options =====
" jump to the last position when reopening a file
autocmd BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif

" highlight extra whitespace
match Error /\s\+$/
autocmd BufWinEnter * match Error /\s\+$/
autocmd InsertEnter * match Error /\s\+\%#\@<!$/
autocmd InsertLeave * match Error /\s\+$/
function! s:StripTrailingWhitespace()
    if !&binary && &filetype != 'diff'
        normal mz
        normal Hmy
        %s/\s\+$//e
        normal 'yz<CR>
        normal `z
    endif
endfunction
command! StripTrailingWhitespace :call s:StripTrailingWhitespace()

" utility function to show assembly output
function! s:ShowASM()
    if &filetype != 'cpp' && &filetype != 'c'
        return
    endif
    let filename = expand("%r")
    let tmpfile = "/tmp/disassembled_" . expand("%:r") . ".s"
    execute "!g++ -std=c++20 -S -O3 -masm=intel -fno-asynchronous-unwind-tables " . filename . " -o " . tmpfile
    execute "split" . tmpfile
    normal gg
endfunction
command! ShowASM :call s:ShowASM()

" open quickfix list after commands like :make
autocmd QuickFixCmdPost * copen | RefreshStatus

" use :Man and configure cppman
runtime ftplugin/man.vim
function! s:CppMan(str)
    execute '!cppman ' . a:str
endfunction
command! -nargs=1 CppMan :call s:CppMan(<f-args>)

" use clang-format
function! s:ClangFormat(first, last)
    let l:winview = winsaveview()
    execute a:first . "," . a:last . "!clang-format --style=WebKit"
    call winrestview(l:winview)
endfunction
command! -range=% ClangFormat call <sid>ClangFormat (<line1>, <line2>)

" filetypes
"autocmd BufNewFile,BufRead *.asm,*.inc set filetype=snes
autocmd BufNewFile,BufRead *.qbs setfiletype qbs
autocmd BufNewFile,BufRead *.pro,*.pri set filetype=qmake
autocmd BufNewFile,BufRead *.qml setfiletype qml
autocmd BufNewFile,BufRead *.qrc setfiletype xml
autocmd BufNewFile,BufRead *.ts setfiletype xml
autocmd BufNewFile,BufRead *.ui setfiletype xml

" language specific settings
let c_gnu = 1
let c_space_errors = 1
let c_curly_error = 1
let c_ansi_typedefs = 1
let c_ansi_constants = 1
let java_highlight_java_lang_ids=1
let java_highlight_java_io=1

" ===== plugin settings =====
" nerdtree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
let NERDTreeDirArrows=1
" gutentags
let g:gutentags_add_default_project_roots = 0
let g:gutentags_project_root = ['.git', '.hg', '.svn', 'Makefile']
let g:gutentags_cache_dir = expand('~/.cache/vim/ctags/')
command! -nargs=0 GutentagsClearCache call system('rm ' . g:gutentags_cache_dir . '/*')
let g:gutentags_generate_on_new = 1
let g:gutentags_generate_on_missing = 1
let g:gutentags_generate_on_write = 1
let g:gutentags_generate_on_empty_buffer = 0
let g:gutentags_ctags_extra_args=[ '--tag-relative=yes', '--fields=+S', ]
let g:gutentags_ctags_exclude=[
            \ 'build', 'dist', 'bin', 'cache', 'debug', 'release',
            \ 'compiled', 'docs', 'example', 'bundle', 'vendor', '.md',
            \ '.json',
            \ ]
" fswitch
au BufEnter *.hpp let b:fswitchdst = "cpp"
au BufEnter *.cpp let b:fswitchdst = "hpp"
" disable netrw
let loaded_netrwPlugin = 1
" ultisnips
let g:UltiSnipsExpandTrigger = '<tab>'
let g:UltiSnipsJumpForwardTrigger = '<tab>'
let g:UltiSnipsJumpBackwardTrigger = '<s-tab>'
" dirvish
let g:dirvish_mode = ':sort ,^.*[\/], | :silent keeppatterns g@\v/\.[^\/]+/?$@d _'
augroup dirvish_config
    autocmd!
    autocmd FileType dirvish nnoremap <silent><buffer>
        \ gh :silent keeppatterns g@\v/\.[^\/]+/?$@d _<cr>:setl cole=3<cr>
    autocmd FileType dirvish :RefreshStatus
augroup END
" call dirvish#add_icon_fn({pathname -> WebDevIconsGetFileTypeSymbol(pathname) . '   '})

" ===== statusline =====
let g:currentmode={
    \ 'n'       : 'Normale',   'no' : 'N·Attesa',    'v'  : 'Visuale',       'V'  : 'V·Riga',
    \ "\<c-v>"  : 'V·Blocco',  's'  : 'Selezione',   'S'  : 'S·Riga',        '^S' : 'S·Blocco',
    \ 'i'       : 'Inserisci', 'R'  : 'Sostituisci', 'Rv' : 'V·Sostituisci', 'c'  : 'Comando',
    \ 'cv'      : 'Vim Ex',    'ce' : 'Ex',          'r'  : 'Prompt',        'rm' : 'Di piu',
    \ 'r?'      : 'Conferma',  '!'  : 'Shell',       't'  : 'Terminale',
    \}
let g:mode_colors={
    \ 'n'       : 'PMenuSel',   'no' : 'PMenuSel',    'v'  : 'DiffChange',    'V'  : 'DiffChange',
    \ "\<c-v>"  : 'DiffChange', 's'  : 'DiffDelete',  'S'  : 'DiffDelete',    '^S' : 'DiffDelete',
    \ 'i'       : 'DiffAdd',    'R'  : 'DiffDelete',  'Rv' : 'DiffDelete',    'c'  : 'PMenuSel'  ,
    \ 'cv'      : 'PMenuSel',   'ce' : 'PMenuSel',    'r'  : 'PMenuSel',      'rm' : 'PMenuSel'  ,
    \ 'r?'      : 'PMenuSel',   '!'  : 'PMenuSel',    't'  : 'PMenuSel',
    \}

function! Status(winnum)
    let stat=''
    let active = a:winnum == winnr()
    let bufnum = winbufnr(a:winnum)
    let type = getbufvar(bufnum, '&buftype')
    let filetype = getbufvar(bufnum, '&ft')
    let stat .= active ? '%#' . g:mode_colors[mode()] . '#  %{toupper(g:currentmode[mode()])}  ' : '%4*  INATTIVO  '
    let stat .= '%#StatusLine#'
    if type ==# 'nofile'
        let stat.=active ? '%3* ' : ' '
        if filetype ==# "nerdtree"
            let stat.='NERDTree'
        elseif filetype ==# 'man'
            let stat.='man'
        elseif filetype ==# 'dirvish'
            let stat.='dirvish: ' . bufname(bufnum) . ' '
        else
            let stat.='???'
        endif
        let stat.='%#StatusLine#'
    else
        let stat .= ' %n: '
        let stat .= active ? '%3*' : ''
        let stat .= type ==# 'help' ? '[Aiuto] ' : ''
        let stat .= '%f%#StatusLine#'
        let stat .= getbufvar(bufnum, '&modified') ? '%2* [+] %#StatusLine#' : ''
        let stat .= getbufvar(bufnum, '&readonly') || !getbufvar(bufnum, '&modifiable') ? '%1*  %#StatusLine#'   : ''
        let stat .= '%w%<%='
        let stat .= active ? gutentags#statusline('[', ']') . ' ' : ''
        let stat .= filetype ==# '' ? 'normal text ' : filetype . ' '
        let stat .= WebDevIconsGetFileTypeSymbol(bufname(bufnum)) . '  '
        let stat .= active ? '%#PMenuSel#' : '%4*'
        let stat .= ' %l, %v :: %L '
    endif
    return stat
endfunction

function! s:RefreshStatus()
    " for each window set statusline to whatever Status() returns
    for nr in range(1, winnr('$'))
        call setwinvar(nr, '&statusline', '%!Status(' . nr . ')')
    endfor
endfunction
command! RefreshStatus :call <SID>RefreshStatus()
augroup status
    autocmd!
    autocmd VimEnter,VimLeave,WinEnter,WinLeave,BufWinEnter,BufWinLeave * :RefreshStatus
augroup END

" ===== mappings =====
" set <Leader>
let mapleader = ","
" use arrow keys for window management
nnoremap <Down>  :resize +2<CR>
nnoremap <Up>    :resize -2<CR>
nnoremap <Left>  :vertical resize +2<CR>
nnoremap <Right> :vertical resize -2<CR>
" Moves a line up/down
nnoremap <S-Down> ddp
nnoremap <S-Up> ddkP

nnoremap <Leader>k <C-w>k
nnoremap <Leader>j <C-w>j
nnoremap <Leader>h <C-w>h
nnoremap <Leader>l <C-w>l
" NERDtree shortcut
nnoremap <C-n> :NERDTreeToggle<CR> :RefreshStatus<CR>
" autoclosing brackets
inoremap (<CR> (<CR>)<Esc>O
inoremap {<CR> {<CR>}<Esc>O
inoremap {; {<CR>};<Esc>O
inoremap {, {<CR>},<Esc>O
inoremap [<CR> [<CR>]<Esc>O
inoremap [; [<CR>];<Esc>O
inoremap [, [<CR>],<Esc>O
" copy to system clipboard
" xnoremap <leader>c "+y
noremap <leader>s :sp **/
noremap <leader>v :vsp **/
" switch buffers using ,b
nnoremap <leader>b :ls<CR>:b<space>
" better :e
nnoremap <leader>e :e **/
" quick switch to last buffer
nnoremap <leader>q :b#<CR>
" obvious
noremap Y y$
" au FileType cpp nnoremap <buffer>K :ShortcutCppMan<CR>
" au FileType c,cpp nnoremap <buffer><leader>lf :<C-u>ClangFormat<CR>
" au FileType c,cpp vnoremap <buffer><leader>lf :ClangFormat<CR>
nnoremap <silent> <leader>ok :FSSplitAbove<cr>
nnoremap <silent> <leader>oj :FSSplitBelow<cr>
nnoremap <silent> <leader>oh :FSSplitLeft<cr>
nnoremap <silent> <leader>ol :FSSplitRight<cr>
" autocompletion mappings
"inoremap <silent> <leader>n <C-x><C-n>
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
"inoremap <expr> <Esc> pumvisible() ? "\<C-e>" : "<Esc>"
"inoremap <C-x> <Esc>:echo "C-x"<CR>i<C-x>
"inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
"            \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
"inoremap <expr> <M-,> pumvisible() ? '<C-n>' :
"  \ '<C-x><C-o><C-n><C-p><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
